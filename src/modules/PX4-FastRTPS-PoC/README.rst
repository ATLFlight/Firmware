PX4-FastRTPS-PoC
================

This is a proof of concept to communicate a **Pixracer Autopilot** and a **Raspberry Pi** through serial ports using **CDR serialization**, aims to get information from a drone and carry to the DDS world through **Fast RTPS**.

.. image:: doc/scheme.png

Pixracer firmware
-----------------

On the *Pixracer* side, it will be used an application running an uORB node. This node will be subscribed to the IMU sensor data via the *sensor_combined* topic. The applications read the message in a loop, serializes the struct and writes it trough an UART port selected by the user.

To compile this appication along the **PX4** firmware it is needed to add the `eprosima_cdr <https://github.com/eProsima/PX4-FastRTPS-PoC/blob/master/pixracer/src/examples/eprosima_cdr>`_ folder on the examples folder (located on `src/examples <https://github.com/PX4/Firmware/tree/master/src/examples>`_). Then, the application must be registered in *NuttShell* adding a new line in `nuttx_px4fmu-v4_default.cmake <https://github.com/PX4/Firmware/blob/master/cmake/configs/nuttx_px4fmu-v4_default.cmake>`_ as described in the PX4 `documentation <https://dev.px4.io/tutorial-hello-sky.html#step-3-register-the-application-in-nuttshell-and-build-it>`_:

.. code-block:: shell

    # eProsima app
    examples/eprosima_cdr

After uploading the firmware, the application can be launched on *NuttShell* typing its name and passing an available serial port as argument. Using */dev/ttyACM0*
will use the USB port as output. Using */dev/ttyS1* or */dev/ttyS2* will write the output trough TELEM1 or TELEM2 ports respectively.

.. code-block:: shell

    > eprosima_cdr /dev/ttyACM0  #or /dev/ttySn

**NOTE**: If the UART port selected is busy, it's possible that Mavlink applications were using them. If it is the case, you can stop Mavlink from NuttShell typing:

.. code-block:: shell

    > mavlink stop-all

Raspberry PI application
------------------------

In this project the *Raspberry Pi* will have two functions: get the sensor data from the Pixracer and publish it to a **Fast RTPS** environment. In the `raspberry <https://github.com/eProsima/PX4-FastRTPS-PoC/blob/master/raspberry>`_ folder there is an example Fast RTPS application generated with *fastrtpsgen*. In this application you can launch a publisher or subcriber which are using an idl file with the same attributes than the msg structure generated by uORB. The publisher read data from the UART, deserializes it, and make a Fast RTPS message mapping the attributes from the uORB message. The subscriber simply receives the Fast RTPS messages and print them to the terminal. The subscriber can be launched on the Raspberry Pi or in any another device connected in the same network.

Before runnning the application, it is needed to have installed Fast RTPS. Visit it installation `manual <http://eprosima-fast-rtps.readthedocs.io/en/latest/sources.html>`_ for more information. For compiling the application run this commands in the Raspberry:

.. code-block:: shell

    $ git clone https://github.com/eProsima/PX4-FastRTPS-PoC.git
    $ cd PX4-FastRTPS-PoC/raspberry
    $ mkdir build && cd build
    $ cmake ..
    $ make

Now, to launch the publisher run:

.. code-block:: shell

    $ ./raspberry_px4 publisher /dev/ttyACM0 #or the selected UART

And, for launching the subscriber run:

.. code-block:: shell

    $ ./raspberry_px4 subscriber

**NOTE**: Normally, it's necessary set up the UART port in the Raspberry Pi. To enable the serial port available on Raspberry Pi connector:

1. Make sure the userid (default is pi) is a member of the dialout group:

.. code-block:: shell

    $ groups pi
    $ sudo usermod -a -G dialout pi

2. You need to stop the already running on the GPIO serial console:

.. code-block:: shell

    $ sudo raspi-config

Go to *Interfacing options > Serial*, NO to *Would you like a login shell to be accessible over serial?*, valid and reboot.

3. Check UART in kernel:

.. code-block:: shell

   $ sudo vi /boot/config.txt

And enable UART setting *enable_uart=1*.

Result
------

The entire application will follow this flow chart:

.. image:: doc/architecture.png

If all steps has been followed, you should see this output on the subscriber side of Fast RTPS.

.. image:: doc/subscriber.png

A video of this final process as demostration is available on `https://youtu.be/NF65EPD-6aY <https://youtu.be/NF65EPD-6aY>`_
